# leetcodeNote
## 717. 1比特与2比特字符
### 描述:
有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。
现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。
### 示例1：
```
输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
```
### 示例2：
```
输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。
```
### 注意:
1 <= len(bits) <= 1000.
bits[i] 总是0 或 1.
### 解题思路：
从头开始检测，采用一个标志位来判断当前的字符是1比特还是2比特，当检测到比特1时，表示为2比特字符，跳过下一个字符检测，且置标志位为false,
否则检测到比特为0，表示1比特字符。标志位为true.这样检测完全部的数据后，就可以知道最后一个字符是1比特还是2比特。直接返回。

### 代码：
```cpp
class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int iLength = bits.size();
        bool bFlag = false;
        int i = 0;
        for(i = 0; i < iLength; i++)
        {
            if(bits[i] == 1)
            {
                i = i+1;
                bFlag = false;
            }
            else
            {
                bFlag = true;
            }
        }
        return bFlag;
    }
};
```
/********************************************************************************************************************************/
## 456. 132模式
### 描述：
给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。
注意：n 的值小于15000。
### 示例1：
```
输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
```
### 示例2：
```
输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
```
### 示例3：
```
输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
```
### 解题思路：
我们先固定一个数字，然后去遍历另外2个数字，这里我们可以先确定最小的数字，用一个变量 mn 表示。初始化为整形最大值。然后在遍历数字的时候，每次用当前数字来更新 mn ,然后我们判断，若 mn 为当前数字就跳过，因为需要找到数字j的位置，数字j是大于i的。 mn 表示的就是数字i的值。这样数字i和j都确定了。就可以遍历数字k了。遍历的范围是数组的最后一个位置到数字j 之间。只要中间有任何一个满足 mn < nums[k] && nums[j] > nums[k] 的关系就直接返回 true.
### 代码：
```cpp
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        
        if(nums.size() < 3){
            return false;
        }

        int n = nums.size(), mn = INT_MAX;
        for (int j = 0; j < n; ++j) {
            mn = min(mn, nums[j]);
            if (mn == nums[j]) continue;
            for (int k = n - 1; k > j; --k) {
                if (mn < nums[k] && nums[j] > nums[k]) return true;
            }
        }
        return false;
    }
};
```


