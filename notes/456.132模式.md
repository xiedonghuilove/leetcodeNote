## 456. 132模式
### 描述：
给定一个整数序列：a1, a2, ..., an，一个132模式的子序列 ai, aj, ak 被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有132模式的子序列。
注意：n 的值小于15000。
### 示例1：
```
输入: [1, 2, 3, 4]
输出: False
解释: 序列中不存在132模式的子序列。
```
### 示例2：
```
输入: [3, 1, 4, 2]
输出: True
解释: 序列中有 1 个132模式的子序列： [1, 4, 2].
```
### 示例3：
```
输入: [-1, 3, 2, 0]
输出: True
解释: 序列中有 3 个132模式的的子序列: [-1, 3, 2], [-1, 3, 0] 和 [-1, 2, 0].
```
### 解题思路：
我们先固定一个数字，然后去遍历另外2个数字，这里我们可以先确定最小的数字，用一个变量 mn 表示。初始化为整形最大值。然后在遍历数字的时候，每次用当前数字来更新 mn ,然后我们判断，若 mn 为当前数字就跳过，因为需要找到数字j的位置，数字j是大于i的。 mn 表示的就是数字i的值。这样数字i和j都确定了。就可以遍历数字k了。遍历的范围是数组的最后一个位置到数字j 之间。只要中间有任何一个满足 mn < nums[k] && nums[j] > nums[k] 的关系就直接返回 true.
### 代码：
```cpp
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        
        if(nums.size() < 3){
            return false;
        }

        int n = nums.size(), mn = INT_MAX;
        for (int j = 0; j < n; ++j) {
            mn = min(mn, nums[j]);
            if (mn == nums[j]) continue;
            for (int k = n - 1; k > j; --k) {
                if (mn < nums[k] && nums[j] > nums[k]) return true;
            }
        }
        return false;
    }
};
```